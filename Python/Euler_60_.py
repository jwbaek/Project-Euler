import itertools
from decimal import *
from Common_Functions import *
from math import *
"""
PROBLEM 60

The primes 3, 7, 109, and 673, are quite remarkable.
By taking any two primes and concatenating them in any order
the result will always be prime.

For example, taking 7 and 109, both 7109 and 1097 are prime.
The sum of these four primes, 792, represents the lowest sum
for a set of four primes with this property.

Find the lowest sum for a set of five primes for which any two primes
concatenate to produce another prime.
"""

max_prime_60 = 9000
primes_60 = prime_sieve(max_prime_60)

def add_to_dict(p1, p2, concat_primes_dict):
    if p1 not in concat_primes_dict:
        concat_primes_dict[p1]= [p2]
    else:
        flag = True
        for old_prime in concat_primes_dict[p1]:
            if not has_remarkable_property((old_prime, p2)):
                flag = False
                break
        if flag:
            concat_primes_dict[p1].append(p2)

def prob60():
    concat_primes_dict = {}
    for prime_set in itertools.combinations(primes_60, 2):
        if has_remarkable_property(prime_set):
            add_to_dict(prime_set[0], prime_set[1], concat_primes_dict)
            add_to_dict(prime_set[1], prime_set[0], concat_primes_dict)
    possible_sols = []
    # find all primes that have 4 or more concat_primes
    for (k, v) in concat_primes_dict.iteritems():
        if len(v) >= 4:
            v.append(k)
            possible_sols.append(v)
    if not possible_sols:
        print 'NONE FOUND FOR', max_prime_60
        return
    # find the minimum of all possible solutions
    minimum = sum(possible_sols[0])
    for prime_set in possible_sols:
        for tuple5 in itertools.combinations(prime_set, 5):
            sum_primes = sum(tuple5)
            if sum_primes < minimum:
                minimum = sum_primes
            if sum_primes == 103:
                print tuple5
    return minimum

def has_remarkable_property(prime_set):
    for tup in itertools.permutations(prime_set, 2):
        concat = concat_nums(tup[0], tup[1])
        if concat >= max_prime_60:
            if not isPrime(concat):
                return False
        elif concat not in primes_60:
            return False
    return True

def concat_nums(num1, num2):
    return int(str(num1) + str(num2))


"""
PROBLEM 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P4,n=n^2	 	    1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281,
has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first
two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
and pentagonal (P5,44=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers
for which each polygonal type: triangle, square, pentagonal, hexagonal,
heptagonal, and octagonal, is represented by a different number in the set.
"""
import math

# I should have probably just created a list of all of these numbers
# that are four digits, insead of creating a is<n-gonal> function for each number
def isTriangular(n):
    x = (math.sqrt(8*n + 1) - 1 )/2
    if math.floor(x) == x:
        return x
    return False
def isSquare(n):
    x = (math.sqrt(n))
    if math.floor(x) == x:
        return x
    return False
def isHexagonal(n):
    x = (math.sqrt(8*n + 1) + 1 )/4
    if math.floor(x) == x:
        return x
    return False
def isHeptagonal(n):
    x = (math.sqrt(40*n + 9) + 3 )/10
    if math.floor(x) == x:
        return x
    return False
def isOctagonal(n):
    x = (math.sqrt(12*n + 4) + 2 )/6
    if math.floor(x) == x:
        return x
    return False

def isPentagonal(n):
    x = (math.sqrt(24*n + 1) + 1 )/6
    if math.floor(x) == x:
        return x
    return False

def octagonal(n):
    return n*(3*n-2)

def prob61():
    n = 19
    left = [3, 4, 5, 6, 7]
    for n in range(19, 60):
        list_so_far = [octagonal(n)]
        first = octagonal(n)
        found = find_all_sets(list_so_far, left)
        if found:
            return found, sum(found)

func_dict = {3:isTriangular, 4:isSquare, 5:isPentagonal, 6:isHexagonal, 7:isHeptagonal, 8:isOctagonal}
def list_startswith(number, startswith, endswith=False):
    func = func_dict[number]
    li= []
    found = -1
    for n in xrange(startswith*100, startswith*100+100):
        if tensdigit(n) != 0 and func(n):
            if endswith:
                if n%100 == endswith:
                    li.append(n)
            else:
                li.append(n)
            found = func(n)
    return li

def tensdigit(n):
    return n/10%10

def find_all_sets(so_far, left):
    if not left:
        return so_far
    li_tuples = []
    endswith = False
    if len(left) == 1:
        endswith = so_far[0]/100
    for i in left:
        li= list_startswith(i, so_far[-1]%100, endswith = endswith)
        if li:
            for new in li:
                local_so_far = so_far[:]
                local_so_far.append(new)
                local_left = left[:]
                local_left.remove(i)
                li_tuples.append((local_so_far, local_left))
    for (sofar, whatsleft) in li_tuples:
        result = find_all_sets(sofar, whatsleft)
        if result:
            return result
    return False

"""
PROBLEM 62

The cube, 41063625 (345^3), can be permuted to produce two other cubes:
    56623104 (384^3) and 66430125 (405^3).
In fact, 41063625 is the smallest cube which has exactly
three permutations of its digits which are also cube.

Find the smallest cube for which exactly five permutations of its digits are cube.
"""
def prob62():
    length = 12
    sorted_dict = {} # sorted str: (count, min_value)
    cubes = [n**3 for n in xrange(10000) if has_ndigits(n**3,length)]
    for num in cubes:
        sorted_str = "".join(sorted(str(num)))
        # if key already exists
        if sorted_str in sorted_dict:
            sorted_dict[sorted_str][0] += 1
            if num < sorted_dict[sorted_str][1]:
                sorted_dict[sorted_str][1] = num
        else:
            sorted_dict[sorted_str] = [1, num]
    minimum = 10**13
    # find min
    for (k, v) in sorted_dict.iteritems():
        if v[0] == 5 and v[1] < minimum:
            minimum = v[1]
    return minimum


def is_permutation(n1, n2):
    str1 = str(n1)
    str2= str(n2)
    if len(str1) == len(str2):
        return sorted(str(n1)) == sorted(str(n2))
    return 0

def has_ndigits(num, digits):
    return len(str(num)) == digits

"""
PROBLEM 63

The 5-digit number, 16807=7^5, is also a fifth power.
Similarly, the 9-digit number, 134217728=8^9, is a ninth power.

How many n-digit positive integers exist which are also an nth power?

"""

def prob63():
    count = 0
    for n in range(1,10):
        exp = 1
        digits_power = 1
        while digits_power >= exp-1:
            power = n**exp
            digits_power = num_digits(power)
            if exp == digits_power:
                count += 1
            exp += 1
    return count

def num_digits(n):
    return len(str(n))

"""
PROBLEM 69

Euler's Totient function, ?(n) [sometimes called the phi function],
is used to determine the number of numbers less than n
which are relatively prime to n. For example, as 1, 2, 4, 5, 7, and 8,
are all less than nine and relatively prime to nine, ?(9)=6.

n	Relatively Prime	?(n)	  n/?(n)
2	1	                  1	        2
3	1,2	                  2	        1.5
4	1,3	                  2       	2
5	1,2,3,4	              4	        1.25
6	1,5	                  2	        3
7	1,2,3,4,5,6	          6	        1.1666...
8	1,3,5,7	              4	        2
9	1,2,4,5,7,8	          6	        1.5
10	1,3,7,9	              4      	2.5
It can be seen that n=6 produces a maximum n/?(n) for n <= 10.

Find the value of n <= 1,000,000 for which n/?(n) is a maximum.

Had help from the internet.
"""

# multiply primes until over 1,000,000
def prob69():
    primes_set = prime_sieve(1000)
    primes = list(primes_set)
    primes.sort()
    prod = 1
    for num in primes:
        prod *= num
        if prod > 1000000:
            return prod/num

"""
PROBLEM 71
Consider the fraction, n/d, where n and d are positive integers.
 If nd and HCF(n,d)=1, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for d <= 8
in ascending order of size, we get:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

It can be seen that 2/5 is the fraction immediately to the left of 3/7.

By listing the set of reduced proper fractions for d <= 1,000,000
in ascending order of size, find the numerator of the fraction
 immediately to the left of 3/7.
"""
def reduce(num, denom):
    g = gcd(num, denom)
    return num/g, denom/g

def prob71():
    left_num = 2
    left_denom = 5
    left_so_far = Decimal(left_num)/Decimal(left_denom)

    to_find = Decimal(3)/Decimal(7)
    biggest = 1000000
    for denom in xrange(8,biggest):
        # find biggest numerator such that numerator/denominator < 3/7
        curr_num = int(math.floor(denom*to_find))
        curr_frac = Decimal(curr_num)/Decimal(denom)
        n, d = reduce(curr_num, denom)
        if curr_frac > left_so_far and not (n ==3 and d==7):
            left_so_far = curr_frac
            left_num = n
            left_denom = d
    return left_num, left_denom

"""
PROBLEM 72

Consider the fraction, n/d, where n and d are positive integers. 
If nd and HCF(n,d)=1, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for d <= 8 in ascending order of size, we get:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

It can be seen that there are 21 elements in this set.

How many elements would be contained in the set of reduced proper fractions for d <= 1,000,000?
"""

# INCOMPLETE
def prob72():
    largest = 1000000
    count = (Decimal(largest)/2)*(Decimal(largest)+1)
    d = dict([(k,0) for k in range(1,largest+1)])
    for i in range(2,largest+1):
        for j in range(2,i+1):
            if gcd(i,j) != 1:
                count -= 1
    return count
        

"""
PROBLEM 73

Consider the fraction, n/d, where n and d are positive integers. If nd and HCF(n,d)=1, it is called a reduced proper fraction.

If we list the set of reduced proper fractions for d  8 in ascending order of size, we get:

1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3, 5/7, 3/4, 4/5, 5/6, 6/7, 7/8

It can be seen that there are 3 fractions between 1/3 and 1/2.

How many fractions lie between 1/3 and 1/2 in the sorted set of reduced proper fractions for d <= 12,000?
"""

def prob73():
    frac_set = set([])
    for i in range(5,12001):
        third = i/3 +1
        curr = third
        while curr*2 < i:
            num, denom = reduce(curr, i)
            frac_set.add((num, denom))
            curr += 1
    return len(frac_set)

def reduce(num, denom):
    g = gcd(num, denom)
    return num/g, denom/g

"""
PROBLEM 81

In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right,
by only moving to the right and down, is indicated in bold red and is equal to 2427.


131	673	234	103	18
201	96	342	965	150
630	803	746	422	111
537	699	497	121	956
805	732	524	37	331

Find the minimal path sum, in matrix.txt (right click and 'Save Link/Target As...'),
a 31K text file containing a 80 by 80 matrix, from the top left to the bottom right
by only moving right and down.
"""
prob81max = 79
def prob81():
    f = open("matrix.txt")
    matrix= []
    for line in f:
        matrix.append([int(l) for l in line.split(",")])
    memoized = [[-1 for i in range(80)] for j in range(80)]
    return findMinPath81(0,0,matrix, memoized)

def findMinPath81(row, col, matrix, memoized):
    curr = matrix[row][col]
    if row == prob81max and col == prob81max:
        return curr
    elif memoized[row][col] == -1:
        if row == prob81max:
            memoized[row][col] = curr+findMinPath81(row, col+1, matrix, memoized)
        elif col == prob81max:
            memoized[row][col] = curr+findMinPath81(row+1, col, matrix, memoized)
        else:
            memoized[row][col] = curr+min(findMinPath81(row+1, col, matrix, memoized),findMinPath(row, col+1, matrix, memoized))
    return memoized[row][col]

"""
PROBLEM 82

NOTE: This problem is a more challenging version of Problem 81.

The minimal path sum in the 5 by 5 matrix below,
by starting in any cell in the left column and
finishing in any cell in the right column, and only moving up,
down, and right, is indicated in red and bold; the sum is equal to 994.


131 673 234 103 18
201 96  342 965 150
630 803 746 422 111
537 699 497 121 956
805 732 524 37  331

Find the minimal path sum, in matrix.txt (right click and '
    Save Link/Target As...'), a 31K text file containing a 80 by 80 matrix,
from the left column to the right column.
"""

def prob82():
    f = open("C:\Users\Jackie\Documents\Project Euler\Python\prob81.txt")
    matrix= []
    for line in f:
        matrix.append([int(l) for l in line.split(",")])
    memoized = [[False for i in range(80)] for j in range(80)]
    partial_m = [[{"up":False, "down":False, "right":False} for i in range(80)] for j in range(80)]
    firsts = [findMinPath82(i,0,matrix, memoized, "first", partial_m) for i in range(80)]
    answer= min([findMinPath82(i,0,matrix, memoized, "first", partial_m) for i in range(80)])
    return answer

def findMinPath82(row, col, matrix, memoized, cameFrom, partial_m):
    curr = matrix[row][col]
    toCheck = {"up":1, "down":1, "right":1}
    # if right most
    if col == prob81max:
        memoized[row][col] = curr
    if memoized[row][col]:
        return memoized[row][col]
    else:
        if cameFrom == "up" or partial_m[row][col]["down"]:
            toCheck["down"]=0
        if cameFrom == "down" or partial_m[row][col]["up"]:
            toCheck["up"]=0
        if partial_m[row][col]["right"]:
            toCheck["right"]=0
        # lowest
        if row == prob81max:
            toCheck["down"]=0
            partial_m[row][col]["down"]=-1
        # highest
        elif row == 0:
            toCheck["up"]=0
            partial_m[row][col]["up"]=-1
    partial = curr+findMinHelper(row, col, matrix, memoized, toCheck, partial_m)
    if all(partial_m[row][col].values()):
        memoized[row][col] = curr+min([v for v in partial_m[row][col].values() if v >0])
        return memoized[row][col]
    return partial


def findMinHelper(row, col, matrix, memoized, tocheck, partial_m):
    peers = []
    if tocheck["right"]:
        partial_m[row][col]["right"]= findMinPath82(row, col+1, matrix, memoized, "right", partial_m)
        peers.append(partial_m[row][col]["right"])
    if tocheck["up"]:
        partial_m[row][col]["up"]= findMinPath82(row-1, col, matrix, memoized, "up", partial_m)
        peers.append(partial_m[row][col]["up"])
    if tocheck["down"]:
        partial_m[row][col]["down"]= findMinPath82(row+1, col, matrix, memoized, "down", partial_m)
        peers.append(partial_m[row][col]["down"])
    if not peers:
        return min([v for v in partial_m[row][col].values() if v >0])
    return min(peers)




"""
PROBLEM 92

A number chain is created by continuously adding the square of the digits
in a number to form a new number until it has been seen before.

For example,

44  32  13  10  1  1
85  89  145  42  20  4  16  37  58  89

Therefore any chain that arrives at 1 or 89 will become stuck in an endless loop.
What is most amazing is that EVERY starting number will eventually arrive at 1 or 89.

How many starting numbers below ten million will arrive at 89?
"""

def prob92():
    count = 0
    alreadySeen = {}
    maxSquareOfDigits = 568  # 9^2 * 7 =567
    for num in xrange(1,maxSquareOfDigits+1):
        if num in alreadySeen:
            if alreadySeen[num] == 89:
                count += 1
            continue
        else:
            curr = num
            sequence = set([curr])
            result = 89
            while curr != 89 and curr != 1:
                curr = squareOfDigits(curr)
                sequence.add(curr)
                if curr in alreadySeen:
                    result = alreadySeen[curr]
                    break
            if curr == 1:
                result = 1
            if result== 89:
                count+=1
            for term in sequence:
                alreadySeen[term]=result
    # now alreadySeen contains all info needed till 10,000,000!
    for num in xrange(maxSquareOfDigits+1, 10000001):
        digitsSquare = squareOfDigits(num)
        if alreadySeen[digitsSquare]==89:
            count+=1
    return count

def squareOfDigits(num):
    return sum([int(s)**2 for s in str(num)])


"""
PROBLEM 97
The first known prime found to exceed one million digits was discovered in 1999,
and is a Mersenne prime of the form 269725931; it contains exactly 2,098,960 digits.
Subsequently other Mersenne primes, of the form 2p1, have been found which contain
more digits.

However, in 2004 there was found a massive non-Mersenne prime which contains
 2,357,207 digits: 28433*2^7830457+1.

Find the last ten digits of this prime number.
"""

def prob97():
    return (28433*pow(2, 7830457,10**10) +1)%10**10
