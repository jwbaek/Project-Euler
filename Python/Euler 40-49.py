#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      Jackie
#
# Created:     28/01/2013
# Copyright:   (c) Jackie 2013
# Licence:     <your licence>
#-------------------------------------------------------------------------------
import math
import itertools
from decimal import *
from Common_Functions import *

"""
PROBLEM 40

An irrational decimal fraction is created by concatenating
the positive integers:

0.123456789101112131415161718192021...

It can be seen that the 12th digit of the fractional part is 1.

If dn represents the nth digit of the fractional part,
find the value of the following expression.

d1  d10  d100  d1000  d10000  d100000  d1000000
"""

def prob40():
    i = 1
    li = []
    while 1:
        li.extend(numToList(i))
        if len(li) > 1000000:
            break
        i += 1
    print len(li)
    terms = [1,10,100,1000,10000,100000,1000000]
    prodSoFar = 1
    for num in terms:
        prodSoFar *= li[num-1]
    return prodSoFar

"""
PROBLEM 41

We shall say that an n-digit number is pandigital if
it makes use of all the digits 1 to n exactly once.
For example, 2143 is a 4-digit pandigital and is also prime.

What is the largest n-digit pandigital prime that exists?
"""
import itertools
def prob41():
    maxSoFar = 2143
    numdigits = 4
    while numdigits < 10:
        for li in list(itertools.permutations(range(1,numdigits+1), numdigits)):
            currNum = listToNum(li)
            if li[-1]%2 == 1 and sum(li)%3 != 0 and isPrime(currNum):
                maxSoFar = currNum
        numdigits += 1
    return maxSoFar

"""
PROBLEM 42


The nth term of the sequence of triangle numbers is given by,
tn = ?n(n+1); so the first ten triangle numbers are:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

By converting each letter in a word to a number corresponding
to its alphabetical position and adding these values we form a word value.
For example, the word value for SKY is 19 + 11 + 25 = 55 = t10.
If the word value is a triangle number then we shall call the word
a triangle word.

Using words.txt (right click and 'Save Link/Target As...'),
a 16K text file containing nearly two-thousand common English words,
how many are triangle words?
"""

def prob42():
    f = open("C:\Users\Jackie\Documents\Project Euler\Python\prob42.txt", "r")
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    alphabet = alphabet.upper()
    alphadict= dict((char, alphabet.find(char)+1) for char in alphabet)
    wordValues = []
    for line in f:
        listWords = line.split("\",\"")
        listWords[0] = listWords[0][1:]
        listWords[-1] = listWords[-1][:-1]
        wordValues = [sum([alphadict[char] for char in word]) for word in listWords]

    # wordValues is list of values of all words in txt file
    # list all triangle numbers below maxValue
    maxValue = max(wordValues)
    currValue = 1
    triangleDict = {}   # contains all triangle numbers
    i = 2
    while currValue <= maxValue:
        triangleDict[currValue] = 1
        currValue += i
        i += 1

    # count number of triangle words
    triangleWords = 0
    for value in wordValues:
        if value in triangleDict:
            triangleWords += 1
    return triangleWords


"""
PROBLEM 43

The number, 1406357289, is a 0 to 9 pandigital number
because it is made up of each of the digits 0 to 9 in some order,
but it also has a rather interesting sub-string divisibility property.

Let d1 be the 1st digit, d2 be the 2nd digit, and so on.
In this way, we note the following:

d2d3d4=406 is divisible by 2
d3d4d5=063 is divisible by 3
d4d5d6=635 is divisible by 5
d5d6d7=357 is divisible by 7
d6d7d8=572 is divisible by 11
d7d8d9=728 is divisible by 13
d8d9d10=289 is divisible by 17

Find the sum of all 0 to 9 pandigital numbers with this property.
"""

def prob43():
    digits = [0,1,2,3,4,6,7,8,9]
    perm = list(itertools.permutations(digits, 9))
    sumSoFar = 0
    for num in perm:
        num = list(num)
        if num[3]%2 != 0:
            continue
        num.insert(5,5)
        if meetsConstraints(num):
            sumSoFar += listToNum(num)
    return sumSoFar

def meetsConstraints(li):
    return listToNum(li[7:10])%17 == 0 and listToNum(li[6:9])%13 == 0 and listToNum(li[5:8])%11 == 0 and listToNum(li[4:7])%7 == 0 and listToNum(li[2:5])%3 == 0


"""
PROBLEM 44

Pentagonal numbers are generated by the formula,
 Pn=n(3n-1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
However, their difference, 70  22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk,
for which their sum and difference is pentagonal and
 D = |Pk - Pj| is minimised; what is the value of D?

SOLUTION NOT VERY GOOD. (found ONE solution that happened to be right..)
"""

def prob44():
    minimum = -1
    #pent_numbers = [1, 5, 12]
    pent_numbers = [pentNumber(n) for n in range(1,5001)]
    n = 4
    curr_first = 0
    curr_second = 1
    for i in pent_numbers:
        for j in pent_numbers:
            if i != j and diffSumPentagonal(i,j) != -1:
                print i,
                print j,
                print j-i
                return

# returns the diff of two pent numbers only if
# both the diff and the sum is pentagonal
# if not, returns -1
def diffSumPentagonal(pent1, pent2):
    sumPents = pent1 + pent2
    diffPents = abs(pent1 - pent2)
    if isPentagonal(sumPents) and isPentagonal(diffPents):
        return diffPents
    return -1
    """
    last = list_pents[-1]
    if diffPents not in list_pents:
        return -1
    elif sumPents < list_pents[-1] and sumPents not in list_pents:
        return -1
    else:
        while last < sumPents:
            last = pentNumber(len(list_pents) + 1)
            list_pents.append(last)
        if last != sumPents:
            return -1
        return diffPents
    """

def pentNumber(n):
    return n*(3*n-1)/2



"""
PROBLEM 45

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n-1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.

"""

def prob45():
    n = 144
    while True:
        curr = n*(2*n -1)
        if isPentagonal(curr):
            return curr
        n += 1

def isPentagonal(n):
    x = (math.sqrt(24*n + 1) + 1 )/6
    if math.floor(x) == x:
        return True
    return False

"""
PROBLEM 46

It was proposed by Christian Goldbach that every odd composite number can be written
as the sum of a prime and twice a square.

9 = 7 + 2*1^2
15 = 7 + 222
21 = 3 + 232
25 = 7 + 232
27 = 19 + 222
33 = 31 + 212

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
"""
def prob46():
    curr = 9
    primes = set([2,3,5,7])
    while True:
        if isPrime(curr):
            primes.add(curr)
        else:
            if not isGoldbach(curr,primes):
                return curr
        curr += 2


def isGoldbach(n, primes):
    toSquare = 1
    twiceSquare = 2*toSquare*toSquare
    remaining = n - twiceSquare
    while remaining > 0:
        if remaining in primes:
            return True
        toSquare += 1
        twiceSquare = 2*toSquare*toSquare
        remaining = n - twiceSquare
    return False


"""
PROBLEM 47

The first two consecutive numbers to have two distinct prime factors are:

14 = 2 x 7
15 = 3 x 5

The first three consecutive numbers to have three distinct prime factors are:

644 = 2? x 7 x 23
645 = 3 x 5 x 43
646 = 2 x 17 x 19.

Find the first four consecutive integers to have four distinct primes factors.
What is the first of these numbers?
"""
def prob47():
    i = 124914
    primes = [2,3,5,7]
    while True:
        if lenprimeFactors(i) != 4:
            i += 1
            continue
        elif lenprimeFactors(i + 1) != 4:
            i += 2
            continue
        elif lenprimeFactors(i + 2) != 4:
            i += 3
            continue
        elif lenprimeFactors(i + 3) != 4:
            print i
            i += 4
            continue
        return i



def lenPrimeFactors(n):
    return len(set(prime_factors(n)))

# taken off stackoverflow
def prime_factors(n):
    factors = []
    d = 2
    while (n > 1):
        while (n%d==0):
            factors.append(d)
            n /= d
        d = d + 1
        if (d*d>n):
            if (n>1): factors.append(n);
            break;
    return factors

"""
PROBLEM 48

The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.

Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
"""
def prob48():
    sumSoFar = 0
    for i in range(1,1001):
        sumSoFar += i**i
        sumSoFar %= 10000000000
    return sumSoFar


"""
PROBLEM 49

The arithmetic sequence, 1487, 4817, 8147,
in which each of the terms increases by 3330, is unusual in two ways:
    (i) each of the three terms are prime, and,
    (ii) each of the 4-digit numbers are permutations of one another.

There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes,
exhibiting this property, but there is one other 4-digit increasing sequence.

What 12-digit number do you form by concatenating the three terms in this sequence?
"""
def prob49():
    curr = 1000
    primesTo= prime_sieve(10000)
    primesUnder = prime_sieve(1000)
    primes = primesTo - primesUnder
    primes -= set([1487, 4817, 8147])
    for p in primes:
        found = [p]
        for p2 in primes:
            if p != p2 and isAnagram(p,p2):
                found.append(p2)
        if len(found) >= 3:
            seq = isArithmetic(found)
            if seq:
                return seq


def isAnagram(a,b):
    return sorted(str(a)) == sorted(str(b))

def isArithmetic(li):
    li.sort()
    for seq in itertools.combinations(li,3):
        if (seq[1] - seq[0]) == (seq[2] - seq[1]):
            return seq
    return False






