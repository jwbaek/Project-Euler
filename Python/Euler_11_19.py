#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      Jackie
#
# Created:     30/12/2012
# Copyright:   (c) Jackie 2012
# Licence:     <your licence>
#-------------------------------------------------------------------------------
import time
from Common_Functions import *
"""
PROBLEM 12

The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

"""

def numberOfFactors(n):
    i = 1
    factorsli = []
    while i*i <= n:
        if n%i == 0:
            factorsli.append(i)
            if i*i != n:
                factorsli.append(n/i)
        i+=1
    #print factorsli
    return len(factorsli)

def prob12():
    tricount = 30
    triangular = (1+tricount)*tricount/2
    numFact = numberOfFactors(triangular)
    while numFact < 500:
        tricount += 1
        triangular = (1+tricount)*tricount/2
        numFact = numberOfFactors(triangular)
        #print tricount, numFact
    return triangular

"""
PROBLEM 14

The following iterative sequence is defined for the set of positive integers:

n -> n/2 (n is even)
n -> 3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:

13  40  20  10  5  16  8  4  2  1
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

NOTE: Once the chain starts the terms are allowed to go above one million.
"""

def Collatz(starting, table):
    nextNum = starting
    sequence = [starting]
    count=1
    while (nextNum != 1):
        if (nextNum%2 == 0):
            nextNum /= 2
        else:
            nextNum = 3*nextNum + 1
        sequence.append(nextNum)
        if nextNum < 1000000:
            table[nextNum] = 0
        count += 1
    return count

def prob14():
    start = time.time()
    table = dict((i, 1) for i in range(1,1000000)) # memoize
    i = 999999
    longestSoFar = 999999
    lengthSoFar = Collatz(i, table)
    while i >= 1:
        if table[i] == 1:
            currLength = Collatz(i, table)
            if currLength > lengthSoFar:
                lengthSoFar = currLength
                longestSoFar = i
        i -= 1
    end = time.time()
    print ("Solved in %.2f seconds" % (end-start))
    return longestSoFar

"""
PROBLEM 17

If the numbers 1 to 5 are written out in words:
    one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.

If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?


NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two)
contains 23 letters and 115 (one hundred and fifteen) contains 20 letters.
The use of "and" when writing out numbers is in compliance with British usage.
"""

# define dictionary
dictLet = {}
dictLet[0] = 0
dictLet[1] = 3
dictLet[2] = 3
dictLet[3] = 5
dictLet[4] = 4
dictLet[5] =4
dictLet[6] =3
dictLet[7] =5
dictLet[8] =5
dictLet[9] =4
dictLet[10] =3
dictLet[11] =6
dictLet[12] =6
dictLet[13] =8
dictLet[14] =8
dictLet[15] =7
dictLet[16] =7
dictLet[17] =9
dictLet[18] =8
dictLet[19] =8
dictLet[20] = 6
dictLet[30] = 6
dictLet[40] = 5
dictLet[50] = 5
dictLet[60] = 5
dictLet[70] = 7
dictLet[80] = 6
dictLet[90] = 6
dictLet[100] = 7
dictLet['and'] = 3

def prob17():
    count = 0
    for i in range(1, 1000):
        hundreds = i/100
        tens = (i - hundreds*100)/10
        ones = i - hundreds*100 - tens*10
        if hundreds != 0:
            count += dictLet[hundreds]
            count += dictLet[100]
            if tens != 0 or ones != 0:
                count += dictLet['and']
        if tens == 0:
            count += dictLet[ones]
        elif tens == 1:
            twoDigits = tens*10 + ones
            count += dictLet[twoDigits]
        else:
            count += dictLet[tens*10]
            count += dictLet[ones]
    return count + 8 + 3

"""
PROBLEM 19

You are given the following information, but you may prefer to do some research for yourself.

1 Jan 1900 was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.

A leap year occurs on any year evenly divisible by 4,
but not on a century unless it is divisible by 400.
How many Sundays fell on the first of the month
during the twentieth century (1 Jan 1901 to 31 Dec 2000)?
"""
def prob19():
    count = 0
    day = 0
    for year in range(1901, 2001):
        for month in range(1,13):
            if ( month == 9 or month == 4 or month == 6 or month == 11):
                day += 30
            if (month == 2):
                if (year%4 == 0 and year%100 != 0) or year%400 == 0:
                    day += 29
                else:
                    day += 28
            else:
                day += 31
            if(day%7 == 0):
                count+=1
    return count






